일관성과 합의

내결함성을 지니 분산 시스템을 구축하는데 쓰이는 알고리즘과 프로토콜

유용한 보장을 해주는 범용 추상화를 찾아 이를 구현하고 애플리케이션에서 이 보장에 의존하게 하는 것

분산시ㅡ템 가자 ㅇ중요한 추상화 중 하나는 합의, 모든 노드가 어떤 것을 동의하게 만드는 것

# 1. 일관성 보장

# 2. 선형성

시스템에 데이터 복사보니 하나만 있고 그 데이터를 대상으로 수행하는 모든 연산은  원자적인 것처럼 보이게 만드는 것
선형성은 최신성 보장, 

## (1) 시스템에 선형성을 부여하는 것은 무엇인가?
시스템에 데이터 복사본이 하나뿐인 것처럼 보이게 만드는 것

선형성의 요구사항은 연산 표시를 모은 선들이 항상 시간순으로 진행돼야함
선형성 : 모든 요청과 응답 시점을 기록하고 그것들이 유효한 순차 순서로 배열되는지 확인함으로써 시스템의 동작이 선형적인지 테스트 할 수 있음


직렬성 : 모든 트랜잭션이 여러 객체를 읽고 쓸 수 있느느 상황에서 트랜잭션들의 격리 속성

## (2) 선형성에 기대기

### A. 잠금과 리더 선출
단일 리더 복제를 사용하는 시스템은 리더가 여러 개가 아니라 하나만 존재하도록 보장해야만 함
합의 알고리즘을 통해 선현성 연산을 내결함성이 있는 방식으로 구현

### B. 제약 조건과 유일성 보장

### C. 채널 간 타이밍 의존성

## (3) 선형성 시스템 구현하기

데이터 복사본이 하나만 있는 것처럼 동작하고 그 데이터에 실행되는 모든 연산은 원자적이라는 걸 의미, 데이터 복사본 하나만 사용하는 것

- 단일 리더 복제

- 합의알고리즘(선형성)

- 다중 리더 복제(비선형적)

- 리더없는 복제(아마도 비선형적)

### A. 선형성과 정족수

## (4) 선형성의 비용

### A. CAP 정리

- 애플리케이션에서 선형성을 요구하고 네트워크 문제 때문에 ㅇㄹ부 복제 서버가 다른 복제서버와 연결이 끊기면 일부 복제서버는 연결이 끊긴 동안 요청을 처리할수 없음

- 애플리케이션에서 선형성을 요구하지 않는다면 각 복제 서버가 다른 복제서버와 연결이 끊기더라도 독립적으로 요청을 처리하는 방식으로 쓰기를 처리할 수 있음

네트워크 분단이 생겼을 떄 앨관성과 가용성 중 하나를 선택하라!

### B. 선형성과 네트워크 지연

# 3. 순서화 보장

선형성 레지스터는 데이터 복사본이 하나만 있는 것처럼 동작하고 모든 연산이 어느 시점에 원자적으로 효과가 나타나는 것처럼 보인다고함

## (1) 순서화와 인과성

순서화가 인과성을 보존하는데 도움을 줌

인과성은 이벤트에 순서를 부과, 결과가 나타나기 전에 원인이 발생, 
시스템이 인과성에 의해 부과된 순서를 지키면 시스템은 인과적으로 '일관적'이라고 함

### A. 인과적 순서가 전체 순서는 아니다

- 선형성 : 연산의 전체 순서를 정할 수 있다, 시스템이 데이터 복사본이 하나만 있는 것처럼 동작하고 모든 연산이 원자적이라면 어떤 두 연산에 대해
항상 둘 중 하나가 먼저 실행됐다고 말할 수 있다는 뜻

- 인과성 : 두 이벤트에 인과적 관계가 있다면 이들은 순서가 있지만 이들이 동시에 실행되면 비교핤 웞다

### B. 선형성은 인과적 일관성보다 강하다

선형성은 인과성을 내포함
인과적 일관성은 네트워크 지연 때문에 느려지지않고 네트워크 장애가 발생해도 가용한 일관성 모델 중 가장 강한 것

### C. 인과적 의존성 담기

## (2) 일련번호 순서화

### A. 비인과적 일련번호 생성기

- 각 노드가 자신만의 독립적인 일련번호 집합을 생성할 수 있음, 노드가 두 대 있으면 한 노드는 홀수만 생성하고 다른 노드는 짝수만 생성

- 일련번호 미리 할당

일련번호 인과성에 일관적이지 않다

- 한노드가 짝수를 생성하고 다른 노드가 홀수르르생성하면 짝우용 카운터가 홀수용 카운터보다 뒤쳐지거나 반대상황 발생할 수 있음
- 물리적 시계에서 얻은 타임스탬프는 시계 스큐에 종속적이어서 인과성에 일관적이지 않게 될 수 있음
- 
### B. 램포트 타임스탬프

모든 노드와 모든 클라리언트가 지금까지 본 카운터 값 중 최댓값을 추적하고 모든 요청에 그 최댓값을 포함시킴

#### a. 타임스탬프 순서화로는 충분하지 않다

동시에 접근할 경우 하나는 실패
연산의 전체 순서는 모든 연산을 모은 후에 드러남

## (3) 전체 순서 프로드캐스트
저체 순서 브로드캐스트, 원자적 브로드캐스트
단일리더가 처리 할 수 있는 수준을 넘어설 때, 시스템을 어떻게 확장할 것이낙, 리더에 장애가 발생했을 때 어떻게 장애 복구 처리를 할 것인가

전체 순서 보르드캐스트 : 노드 사이에 메세지를 교환하는 프로토콜로 기술

- 신뢰성 있는 전달 : 어떤 메세지도손실되지않음, 메시지가한 노드에 전달되면 모든 노드에도 전달돔

- 전체 순서가 정해진 전달 : 메세지는 모든 노드에 같은 순서로 전달

### A. 전체 순서 브로드캐스트 사용하기
데이트베이스 복제에 필요, 
모든 메세지가 데이터베이스에 쓰기를나타내고 모든 복제 서버가 같은 쓰기 연산을 같은 순서로 처리하면 복세 서버들은 서로 일관성 있는 상태를 유지
=> 상태 기계 복제

### B. 전체 순서 브로드캐스트를 사용해 선형성 저장소 구현

전체 순서 브로드캐스트는 비동기식, 

1. 메시지 로그를 추가해서 점유하기 원한느 사용자명을 시험적으로 가리킴
2. 로그를 읽고, 추가한 메세지가 되돌아오기를 기다림
3. 원하는 사용자명을 점유하려고 하는 메세지가 있는 지 확인, 원하는 사용자명에 해당하는 첫 번째 메세지가 자신의 메시지라면 성공한 것

- 로그를 통해 순차 읽기를 할 수 있다, 로그에 메세지를 추가하고 르그를 읽어서 메세지가 되돌아왔을 때 실제 읽기를 수행하면 된다
로그 상의 메세지 위치는 읽기가 실행된 시점을 나타냄

- 로그에서 최신 로그 메세지의 위치를 선형적 방법으로 얻을 수 있다면 그 위치를 질의하고 그 위치까지의 모든 항목이 전달되기를 기다린 후 읽기 수행할 수 있음

- 쓰기를 실행할 때 동기식으로 갱신돼서 최신이 보장되는 복제 서버에서 ㅇ릭을 수 있음

### C. 선형성 저장소를 사용해 전체 순서 브로드캐스트 구현하기
# 4. 분산 트랜잭션과 합의

- 리더 선출 : 단일 리더 복제를 사용하는 데이터베이스에서 모든 노드는 어떤 노드가 리더인지 동의해야한다, 
어떤 노드가 네트워크 결함때문에 다른 노드와 통신할 수 없다면 리더십 지위를 놓고 경쟁할 수 있다

- 원자적 커밋 : 여러 노드나 파티션에 걸치 트랜잭션을 지원하는 데이터베이스에는 트랜잭션이 어떤 노드에서는 성공하고 어떤 노드에서는 실패할 수도 있는 문제가 있다
트랜잭션 원자성을 유지하고 싶다면 모든 노드가 트랜잭션의 결과에 동의하게 만들어야한다, 이런 합의 문제를 원자적 커밋 문제가

## (1) 원자적 커밋과 2단계 커밋( SPC )
개별 보조 색인은 주 데이터와 분리된 ㅈ료 구조
따라서 데이터를 변경하면 그에 해당하는 변경은 보조 색인에도 반영돼야한다

### A 단일 노드에서 분산 원자적 커밋으로
단일 데이터베이스 노드에서 실행되는 트랜잭션에게 원자성은 흔히 저장소 엔진에서 구현,
클라이언트가 데이터베이스 노드에게 트랜잭션을 커밋하라고 요청할 떄 데이터베이스는 트랜잭션의 쓰기가 지속성 있게하고 그 후에 디스크에 있는 로그에 커밋 레코드를 추가

-
- 어떤 노드들은 제약 조건 위반이나 충돌을 감지해서 어보트가 필요하게 되지만 다른 노드들은 성공적으로 커밋될 수 있다
- 어떤 커밋 요청은 네트워크에서 손실되어 타임아웃 떄문에 결국 어보트 되지만 다른 커밋 요청은 전달될 수 있다
- 어떤 노드는 커밋 레코드가 완전히 쓰여지기 전에 죽어서 복구할 때 롤백되지만 다른 노드는 성공적으로 커밋될 수 있다


## (2) 2단계 커밋 소개
모든 노드가 커밋되거나 모든 노드가 어보트 되도록 보장하는 알고리즘

코디네이터( 트랜잭션 관리자 )

- 모든 참여자가 커밋할 준비가 됐다는 뜻으로 '네'로 응답하면 코디네이터는 2단계에서 커밋요청을 보내고 커밋이 실제로 일어남
- 참여자 중 누구라도 '아니오'로 응답하면 코디네이터는 2단계에서 모든 노드에 어보트 요청을 보냄

### A. 약속에 관한 시스템

1. 애플리케이션은 분산 트랜잭션을 시작하기를 원할 때 코디네이터에게 트랜잭션 ID를 요청
2. 애플리케이션은 각 참여자에게 단일 노드 트랜잭션을 시작하고 단일 노드 트랜잭션에 전역적으로 유일한 트랜잭션 ID를 붙임
모든 읽기과 쓰기는 단일 노드 트랜잭션 중 하나에서 실행

3. 애플리케이션이 커밋할 준비가 되면 코디네이터는 모든 참여자에게 전역 트랜잭션 ID로 태깅된 준비 요청을 보냄
4. 참여작 준비 요청을 ㅂ다으면 모든 상황에서 트랜잭션을 커밋할 수 있는 지확인, 모든 트랜잭션 데이터를 디스크에 쓰는 것과 충돌이나 제약 조건 위반을 확인학는게 포함
5. 코디네이터가 모든 준비 요청에대해 응답을 받았을 때 트랜잭션을 커밋할 것인지 어보트할 것인지 최종적결정을 함
코디네이터는 추후 죽는 경우에 어떻게 결정했는지 알 수 있도록 그 결정을 디스크에 있는 트랜잭션 로그에 기록 ' 커밋 포인트 '
6. 코디네이터의 결정이 디스크에 쓰여지면 모든 참여자에게 커밋이나 어보트 요청이 전송, 

### B. 코디네이터 장애
준비 요청중에 어떤게 실패하거나 타임아웃이 되면 코디네이터는 트랜잭션을 어보트
커밋이나 어보트 요청이 실패하면 코디네이터는 무한히 재시도

### C. 3단계 커밋

2PC 코디네이터가 복구하기를 기다리느라 멈출 수있다는 사실 때문에 블로킹 원자적 커밋 프로토콜 이라고함

대안으로 3PC, 이론상으로는 노드에 장애가 나도 멈추지 않도록 원자적 커핏 프로토콜을 논블로킹하게 만들 수 있음

## (3) 현실의 분산 트랜잭션

- 데이터베이스 내부 분산 트랜잭션 : 데이터베이스 노드 사이에 내부 트랜잭션을 지원
- 이종 분산 트랜잭션 : 이종 트랜잭션에서 참여자들은 둘 혹은 그 이상의 다른기술, 두 가지 서로 다른 벤더의 데이터베이스, 메시지 브로커처럼 비데이터베이스 시스템일 수도 있음

### A. 정확히 한 번 메세지 처리를
메세지 전달이나 데이터베이스 트랜잭션 중 하나가 실패하면 둘 다 어보트되고 메세지 브로커는 나중에 메세지를 안전하게 다시 전달할 수 있음

### B. XA 트랜잭션

X/pen XA는 이종 기술에 걸친 2단계 커밋을 구현하는 표준

### C. 의심스러운 상태에 있는 동안 잠금을 유지하는 문제가
데이터베이스 트랜잭션으느 보통 더티 쓰기를 막기 위해 그들이 변경한 로우에 로우 수준의 독점적인 잠금을 획득

2단계 커밋을 사용할 때, 잠금을 잡고있어야함, 이런 잠금은 영원히 관리자가 수동으로 상황을 해결할 때까지 유지하고

### D. 코디네이터 장애에서 복구
고아가 된 의심스러운 트랜잭션, 코디네이터가 어떤 이유 때문, 그 결과를 결정할 수 없는 트랜잭션이 생길 수 있음

문제를 해결하려면 잠재적으로 많은 수작업 필요, 

XA 구현에는 코디네이터로부터 확정절 결정을 얻지않고 의심스러운 트랜잭션을 어보트하거나 커밋할지 결정할 수 있는 '경험적 결정' 이있음

### E. 분산 트랜잭션의 제약

## (4) 내결함성을 지닌 합의

하나 또는 그 이 상의 노드들이 값을 제안할 수 있고 합의 알고리즘이 그 값 중 하나를 결정, 

- 균일한 동의 : 어떤 두 노드도 다르게 결정하지않음
- 무결성 : 어떤 노드도 두 번 결정하지 않음
- 유효성 : 한 노드가 값 v를 결정한다면 v는 어떤 노드에서 제안된 것
- 종료 : 죽지않는 모든 노드는 결국 어떤 값을 결정


대부분의 합의 구현은 과반수의 노드에 장애가 나거나 심각한 네트워크 문제가 있더라도 안전성 속성을 항상 만족
대부분 합의 알고리즘 '비잔틴 결함' 비잔틴 결함이 없다고 가정

### A. 합의 알고리즘과 전체 순서 브로드 캐스트
- 합의의 동의 속성 때문에 모든 노드는 같은 메세지를 순서로 전달하도록 결정
- 무결성 속성 때문에 메세지는 중복되지 않음
- 유효성 속성 때문에 메세지는 요염되지 않고 난데없이 조작되지않음
- 중료 속성 떄문에 메세지느 ㄴ손실되지않음

### B. 단일 리더 복제와 합의

합의를 할려면 먼저 합의를 해결해야함

#### a.에포크 번호 붙이기와 정족수
현재 리더가 죽었다고 생각될 때마다 새 노드를 선출하기 위해 노드 사이에서 투표가 시작

선출은 에포크 번호를 장가시키며 따라서 에포크 번호는 전체 순서가 있고 단조 증가

따라서 두번의 투표, 한번 리더 선출, 두 번쨰 리더의 제안에 투표하기 위함

합의 알고리즘은 노드의 과반수로부터 투표를 받으면 됨, 합의 알고리즘은 새로운 리더가 선출된 후 노드를 일관적 상태로 만들어주는 복구과정을 정의해서
안전성 속성이 항상 만족되도록 보장

#### b. 합의의 제약

제안이 결정되기 전에 노드가 제안에 투표하는 과정은 일종의 동기식 복제, 장애 복구시 잠재적으로 손실

합의 알고리즘 동적 멤버십 확장 클러스터에 있는 노드 집합이 시간이 지남에 따라 바뀌는 것을 허용, 

### C. 멤버십과 코디네이션 서비스

- 선형성 원자적 연산 : compare-and-set 연산을 사용해 잠금 구현, 여러 노드가 동시에 같은 연산을 수행할려고 하면 그것들 중 하나만 성공
합의 프로토콜은 노드에 장애가 나거나 어느 시점에 네트워크가 끊기더라도 연산이 원자적이고 선형 적일 것을 보장

- 연산의 전체 순서화 : 클라이언트들이 서로 충돌하는 걸 막기 위해 펜싱 토큰이 필요

- 장애 감지 : 주키퍼 서버에 수명이 긴 세션을 유지하고 클라이언트와 서버는 주기적으로 하트비트를 교환해서 다른 쪽이 여전히 살아 있는 지확인
'단명 노드'

- 변경 알림 : 클라이언트는 다른 클라이언트가 언제 클러스터에 합류했는지 혹은 도 다른 클라이언트에 장애가 났는지 알아 챌 수 있음

#### A. 작업을 노드에 할당

매우 많은 노드에서 과반수 하는건 비효율적, 

#### B. 서비스 찾기

#### C. 멤버십 서비스


# 정리

- 선형성 compare-and-set 레지스터 : 레지스터 현재 값이 연산의 매개변수로 넘겨진 값과 같은지 여부에 따라 값을 설정할지 말지 원자적으로 결정
- 원자적 트랜잭션 커밋 : 데이터베이스는 분산 트랜잭션을 커밋할 것인지 어보트할 것인지 결정
- 전체 순서 브로드캐스트 : 메시지 ㅇ시스템은 메시지 전달할 순서를 결정
- 잠금과 임차권 : 여러 클라이언트들이 잠금이나 임차권을 얻기 위해 경쟁하고 있을 때 잠금은 누가 성공적으로 잠금을 획ㄷ그할지 결정


