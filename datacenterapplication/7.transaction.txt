- 데이터베이스 소프트웨어나 하드웨어는 언제라도 실패할 수 있다
- 애플리케이션은 언제라도 죽을 수 있다
- 네트워크가 끊기면 애플리케이션과 데이터베이스의 연결이 갑자기 끊기거나 데이터베이스 통신이 안될 수 있다
- 여러 클라이언트가 동시에 데이터베이스 쓰기를 실행해서 다른 클라이언트가 쓴 내용을 덮어 쓸 수 있다
- 클라이언트 사이의 경쟁 조건은 예측하지 못한 버그를 유발 할 수 있다


## 1. 애매모호한 트랜잭션의 개념

### (1) ACID의 의미

A : 원자성
C : 일관성
I : 격리성
D : 지속성 
반대는 BASE
consistency isolation durability
#### Atomcity 원자성
쓰기를 이어서 실행하는 도중에 오류가 발생한다면 트랜잭션은 어보트돼야 하고 그때까지 쓰여진 내용은 폐기돼야함

#### consistency 일관성
#### isolation 격리성
동시에 실행되는 트랜잭션들을 서로 방해하지말아야함
#### durability 지속성

### (2) 단일 객체 연산과 다중 객체 연산

### (3) 단일 객체 쓰기
### (4) 다중 객체 트랜잭션의 필요성
### (5) 오류와 어보트 처리량이

## 2. 완화된 격리 수준

동시성 문제는 트랜잭션이 다른 트랜잭션에서 동시에 변경한 데이터를 읽거나 두 트랜잭션이 동시에 같은 데이터를 변경할려고 할 때 나타남

### (1) 커밋 후 읽기

#### 더티 읽기 방지
커밋 후 읽기 격리 수준에서 실행된느 트랜잭션은 더티 읽기를 막아야함

#### 더티 쓰기 방지
트랜잭션들이 여러 객체를 갱신하면 더티 쓰기는 나쁜 결과를 유발, 

### (2) 커밋 후 읽기 구현
로우 수준 잠금을 사용해 더티 쓰기를 방지

동일한 잠금을 써서 객체를 읽기 원하는 트랜잭션이 잠시 잠금을 획득핞 우 읽기가 끝난 후 바로 해제하게 하는 것

## 3. 스냅숏 격리와 반복 읽기

비반복 읽기, 읽기 스큐 

### 스냅숏 격리 구현
더티 쓰기를 바잊하기위해 쓰기 잠금을 사용

다중버전 동시세어 제어(multi-version concurrency control MVCC)

스냅숏 격리를 지원하는 저장소 엔진은 커밋 후 읽기 격리를 위해서 MVCC를 사용

### 일관된 스냅숏을 보는 가시성 규칙
데이터베이스 객체를 읽을 때 트랜잭션 ID를 사용해 어떤 것을 볼 수 있고 어떤 것을 볼 수 없는지 결정

1. 데이터베이스는 각 트랜잭션을 시작할 떄 그 시점에 진행 중인 모든 트랜잭션의 목록을 만듬 , 이 트랜잭션들이 쓴 데이터는 모두 무시
2. 어보트 된 트래냊ㄱ션이 쓴 데이터는 모두 무시된다
3. 트랜잭션 ID가 더 큰 트랜잭션이 쓴 데이터는 그 트랜잭션의 커밋 여부에 관계없이 모두 무시된다
4. 그 밖의 모든 데이터는 애플리케이션의 질의로 볼 수 있다

### 색인과 스냅숏 격리

### 반복 읽기와 혼란스러우 ㄴ이름
SQL 표준에 스냅숏 격리 개념이 없음


### 갱신 손실 방지
갱신 손실 문제, 데이터베이스에서 값을 읽고 변경한 후에 변경된 값을 다시 쓸 때 발생할 수 있음
- 카운터를 증가시키거나 계좌 잔고를 갱신한다
- 복잡한 값을 지역적으로 변경한다, 예를 들어 JSON 문서 내에 있는 리스트에 엘리먼트를 추가되면
- 사용자가 편집한 내용을 저장할 떄 전체 페이지 내용을 서버에 보내서 현재 데이터베이스에 저장된 내용을 덮어 쓰도록 만들어진 위키에서 두명의 사용자가 동시에 같은 페이지르 ㄹ편집

#### (1) 원자적 쓰기 연산
여러 데이터베이스에서 원자적 갱신 연산을 제공 

원자적 연산은 보통 객체를 읽을 떄 그 객체에 독점적인 잠금을 획득해서 구현, 갱신이 적용될 때까지 다른 트랜잭션에서 그 객체를 읽지 못하게 함'(커서 안정성)
ORM의 경우 문제가 발생할 수 있음

#### (2) 명시적인 잠금
애플리케이션에서 갱신할 객체를 명시적으로 잠그는 것
read-modify-write 주기를 수행할 수 있고 다른 트랜잭션이 같은 객체를 읽으려고하면 기다리도록 강제

BEGIN TRANSACTION;

#### (3) 갱신 손실 자동 감지
원자적 연산과 잠금은 READ-MODIFY-WRITE 주기가 순차적으로 실행되도록 강제함으로 갱신 손실을 방지하는 방법
관리자가 갱신 손실을 발견하면 트랜잭션을 어보트하고 READ-MODIFY-WRITE주기를 재시도하도록 강제하는 방법

#### (4) Compare-and-set
원자적 compare-and-set 연산을 제공
값을 마지막으로 읽은 후로 변경되지 않았을 때만 갱신을 허용함으로써 갱신 손실을 회피하는 것

### 3. 쓰기 스큐와 팬텀

#### (1) 쓰기 스큐를 특징짓기

쓰기 스튜(wrtie skew) 트랜잭션이 동시에 실행됐기 때문에 이상 동작이 나타날 수 있었음

- 여러 객체가 관련되므로 원자적 단일 객체 연산은 도움되지않음
- 일부 스냅숏 격리 구현에서 제공디는 갱신 손실 자동 감지도 도움되지않음
- 구체화 뷰를 통해 구현 가능
- 직렬성 격리 수준을 사용할수 없다며 ㄴ트랜잭션이 으존하는 로우를 명시적으로 잠그는 게 차선책
#### (2) 추가적인 쓰기 스큐의 예
스케줄이 충돌하지않도록 보장하려면 직렬성 격리가 필요


#### (3) 쓰기 스큐를 유발하는 팬텀

1. select질의가 어떤 검색 조건에 부합하는 로우를 검색함으로써 어떤 요구사항ㅇ을 만족하는지 확인
2. 첫번쨰 질의의 결과에 따라 애플리케이션 코드는 어떻게 진행할지 결정
3. 애플리케이션이 계속 처리하기로 결정했다면 데이터베이스에 쓰고 트랜잭션을 커밋, 이 쓰기의 효과로 2단계를 걸정한 전제조건이 바뀜

ㄴ어떤 트랜잭션에서 실행한 쓰기가 다른 트랜잭션의 검색 질의 결과를 바꾸는 효과를 팬텀이라고 함

#### (4) 충돌 구체화

### 4. 직렬성
직렬성 격리를 사용, 가장 강력한 격리 수준
여러 트랜잭션이 병렬로 실행되더라도 최종 결과는 동시성 없이 한번에 하나씩 직려로 실행될 떄와 같도록 보장

- 말 그대로 트랜잭션을 순차적으로 실행하기
- 수십년동안 유일한 수단이었던 2단계 자금
- 직렬성 스냅숏 격리같은 낙관적 동시성 제어기법

#### 실제적인 직렬 실행
동시성을 완전히 제거, 

#### 트랜잭션을 스토어드 프로시저 안에 캡슐화하기

#### 파티셔닝

#### 직렬 실행 요약
- 모든 트랜잭션은 작고 빨라야한다, 느린 트랜잭션 하나가 모든 트랜잭션 처리를 지연시킬수 있기 떄문
- 활성화된 데이터셋이 메모리에 적재될 수 있는 경우도 사용이 제한, 거으 ㅣ접근되지 않는 데이터는 잠재적으로 디스크로 옮겨질 수 있지만 단일 스레드 트랜잭션에서 이에 접근해야한다면 시스템이 느려짐
- 쓰기 처리량이 단일 cpu 코어에서 처리할 수 있을 정도로 충분히 낮아짐, 그렇지않으면 여러 파티션에 걸친 코디네이션이 필요하지않도록 트랜잭션을 파티셔닝
- 여러 파티션에 걸친 트랜잭션도 쓸 수 있지만 이것을 사용할 수 있는 정도에느 ㄴ제한이 있음



### 5. 2단계 잠금(2PL)

- 트랜잭션 A가 객체 하나를 읽고 트랜잭션 B가 그 객체에 쓰기 원한다면 B는 진행하기 전에 A가 커밋되거나 어보트될 때까지 기다려야함
- 트랜잭션 A가 객체에 썼고 트랜잭션 B가 그 객체를 읽기 원한다면 B는 진행하기 전에 A가 커밋되거나 어보트 될 때까지 기다려야함

#### 2단계 잠금 구현

읽는 쪽과 쓰는 쪽을 막는 것은 데이터베이스 각 객체에 잠금을 사용해 구현
- 트랜잭션이 객체를 읽기 원한다면 먼저 공유 모드로 잠금을 획득해야함, 동시에 여러 트랜잭션이 공유모드로 잠금을 횓그한느 것은 허용되지만 그 객체에 독점 모드로 잠금을 획득한 트랜잭션이 있으면 
트랜잭션이 완료될 떄까지 기다려야함

- 트랜잭션이 객체를 읽다가 쓰기를 실행할 때는 공유잠금을 독점 잠금으로 업그레이드
- 트랜잭션이 잠금을 획득한 후에는 트랜잭션이 종료될 때까지 잠금을 갖고 있어야함, 
첫번쨰 단계는 잠금을 획득할 떄, 두번째 모든 잠금 해체할 떄

#### 2단계 잠금의 성능
교착상태가 훨씬 더 자주 발생

#### 서술 잠금
직렬성 격리를 쓰는 데이터베이스는 팬텀을 막아야함
=> 서술 잠금이 필요 
- 트랜잭션 A가 SELECT질의 처럼 어떤 조건에 부합하는 객체를 읽기 원한다면 질의의 조건에 대한 공유모드 서술잠금을 획득해야함
다른 트랜잭션 B가 그 조건에 부합하는 어떤 객체에 독점 잠금을 갖고 있으면 A는 질의를 실행하도록 허용되기 전에 B가 잠금을 해제하기 기다려야함
- 트랜잭션 A가 어떤 객체를 삽입, 갱신 삭제하길 원한다면 기존 값이나 새로운 값 중에 기존의 서술 잠금에 부합하는게 있는지 확인
부합하는 서술잠금을 트랜잭션 B가 잡고 있다면 A는 진행하기 전에 B가 커밋되거나 어보트 될때까지 기다려야함

#### 색인 범위 잠금
서술잠금은 잘 작동하지안흥ㅁ
2PL을 지원하는 대부분 데이터베이스 실제로 색인 범위 잠금, 다음 키잠금을 구현
팬텀과 쓰기 스큐로부터 보호 

#### 3. 직렬성 스냅 숏 격리

2단계 잠금은 비관적 동시적 제어 메커니즘, 

#### 오래된 MVCC 읽기 감지하기

#### 과거의 읽기에 영향을 미치는 쓰기 감지하기

#### 직렬성 스냅숏 격리의 성능

## 정리
더티읽기 : 한 클라이언트가 다른 클라이언트가 썻지만 아직 커밋되지않은 데이터를 읽음, 커밋후 읽기 또는 그보다 강한 격리 수준은 더티읽기를 방지

더티쓰기 : 한 클라이언트가 다른 클라이언트가 썻지만 아직 커밋되지않은 데이터를 덮어씀, 거의 모든 트랜잭션 구현은 더티쓰기를 방지

읽기 스큐(비반복읽기) : 클라이언트는 다른 시점에 데이터베이스의 다른 부분을 봄, 이 문제를 막기위한 해결책으로 트랜잭션이 어느 시점의 일관된 스냅숏으로 읽는 스냅숏 격리를 흔히 사용
MVCC를 써서 구현

갱신 손실 : 두 클라이언트가 동시에 read-modify-write 주기를 실행합니다. 한 트랜잭션이 다른 트랜잭션의 변경을 포함하지 않은 채로 다른 트랜잭션이 쓴 내용을 덮어써써 데이터가 손실]

쓰기 스큐 : 트랜잭션이 무언가를 읽고 읽은 값을 기반으로 어떤 결정을 하고 그 결정을 데이터베이스에 씀
그러나 쓰기 실행하는 시점에는 결정의 전제가 더이상 참이 아님

팬텀 읽기 : 트랜잭션이 어떤 검색 조건에 부합하는 객체를 읽는다, 다른 클라이언트가 그 검색 결과에 영향을 주는 쓰기를 실행됐
스냅숏 격리는 간단한 팬텀읽기는 막아주지만 쓰기 스큐 맥락에서 발생하는 팬텀은 색인 범우 잠금처럼 특별한 처리가 필요