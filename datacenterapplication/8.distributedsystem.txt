8 분산 시스템의 골칫거리

# 1. 결함과 부분 장애

## (1) 클라우드 컴퓨팅과 슈퍼컴퓨팅

- 대규모 컴퓨팅의 한쪽 끝에는 고성능 컴퓨터, 수천개의 cpu를 가진 슈퍼컴퓨터는 일기예보다 분자동력학처럼 계산 비용이 매우 높은 과학 계산 작업에 쓰임
슈퍼컴퓨터는 부분장애를 전체 장애로 확대하는 방법으로 처리가
노드 사이에는 공유 메모리와 원격 직접 메모리 접근을 사용해 통신
- 클라우딩 컴퓨팅 멀티 테넌트 데이터센터, IP, 네트워크로 연결된 상용 컴퓨터

# 2. 신뢰성 없는 네트워크

## (1) 현실의 내트워크 결함

## (2) 결함감지
결함있는 노드를 자동 감지 할 수 있어야함
- 로드밸런서는 죽은 노드로 요청을 그만 보내야함
- 단일 리더 복제를 사용하는 분산 데이터베이스에서 리어데 장애가 나면 팔로워 중 하나가 리더로 승격돼야한다

- 노드가 실행 중인 장비에 연결할 수 있지만 목적지 포트에서 수신 대기하는 프로세스가 없다면, 운영체제가 친절하게 RST나 FIN패킷을 응답으로 보내서 TCP 연결을 닫거나 거부
- 노드 프로세스가 죽었지만 노드의 운영체제는 아직 실행중이라면 스크립트로 다른 노드에게 프로세스가 죽었다고 알려서 다른 노드가 만료되기를 기다릴 필요없이 빠르게 역할을 넘겨받을 수 있다
- 뎅터 센터 내 ㅌ네트워크 스위치의 관리 인터페이스에 접근할 수 있으면 질의를 보내 하드웨어 수준의 링크 장애를 감지할 수 있다,
- 접속하려는 IP 주소에 도달할 수 없다고 라우터가 확신하면 ICMP Destination Unreachable 패킷으로 응답할 수도 있음

## (3) 타임아웃과 기약 없는 지연

## (4) 네트워크 혼잡과 큐 대기
- 여러 다른 노드가 동시에 같은 목적지로 패킷을 보내려고 하면 네트워크 스위치는 패킷을 큐에 넣고 한 번에 하나씩 목적지 네트워크 링크로 넘겨야함
네트워크 링크가 붐비면 패킷을 슬롯을 얻을 수 있을 때 까지 잠시 기다려야할 수있음(네트워크 혼잡)

- 패킷이 목적지 장비에 도착했을 때 다른 가상 장비 cpu 코어를 사용하는 동안 수십 밀리초 동안 멈출 떄가 흔함
- TCP는 흐름제어를 수행, 혼잡 회피나 배압이라고도 하는 흐름 제어는 노드가 네트워크 링크나 수신 노드에 과부하를 가하지않도록 자신의 송신율을 제한

## (5) 동기 네트워크 대 비동기 네트워크

# 3. 신뢰성 없는 시계

## (1) 단조 시계 대 일 기준 시계

### A. 일 기준 시계

### B. 단조 시계
타임아웃이나 서비스 응답시간 같은 지속시간을 재는 데 적합


## (2) 시계 동기화와 정확도
일 기준 시계는 NTP 서버나 다른 외부 시간 출처에 맞춰 설정돼야 유용

- 드리프트 현상이 생김, 장비 온도에 따라 변함
- 컴퓨터 시계가 NTP 서버와 너무 많은 차이가 나면 동기화가 거부디거나 로컬 시계가 강제로 리셋될 수도 있다

## (3) 동기화된 시계에 의조하기

## (4) 이벤트 순서화용 타임스탬프를
최종 쓰기 승리(LWW)
'최근'의 정의는 로컬 일 기준 시계에 의존 , 그 시게는 틀릴 수도 있다

## (5) 시계 읽기는 신뢰구간이 있다
## (6) 전역 스냅숏용 동기화된 시계

# 4. 프로세스 중단
리더가 다른 노드들로부터 임차권을 얻는 것

- 모든 스레드를 멈춰야하는 가비지 커렉터가 있음, 애플리케이션 코드와 병렬적으로 실행할 수없음
- 가상 환경에서 가상 정비는 서스펜더됐다가 재개될 수 있음
- 노트북같은 기기 실행이 제멋대로 서스팬드됐다가 재개될 수 있음
- 운영체재가 다른 스레드로 스위치하거나 하이퍼바이저가 다른 가상 장비로 스위치되면 현재 실행 중인 스레드는 코드의 임의 지점에서 멈출 수 있음
- 애플리케이션이 동기식으로 디스크에 접근하면 스레드가 느린 디스크 I/O 연산이 완료되기를 기다리느라 중단될 수 있음
- 운영체제가 디스크로 스왑 할 수 있게 설정됐다면 단순하 메모리 접근만 해도 페이지를 디스크에서 메메로로 로딩하게 하는 페이지 폴트가 발생할 수 있음 느린 I/O연산이 실행되ㅡㄴ동안 스레드는 멈춤
- 유닉스 프로세스는 SIGSTOP  신호르 ㄹ보내 멈출 수 있음

## (1) 응답 시간 보장
시스템에서 실시간 보장을 제공하려면 소프트웨어 스택의 모든 수준에서 지원이 필요, 실시간 운영체제(RTOS)

## (2) 가비지 컬렉션의 영향을 제한하기

# 5. 지식, 진실, 그리고 거짓말
## (1) 진실은 다수결로 결정
여러 분산 알고리즘은 정족수, 노드들 사이의 투표에 의존

## (2) 리더와 잠금
- 스필릿 브레인을 피하기 위해 오직 한 노드만 데이터베이스 파티션의 리더가 될 수 있음
- 특정한 자원이나 객체에 동시에 쓰거나 오염시키느 ㄴ것을 방지하기 위해 오직 하나의 트랜잭션이나 클라이언트만 어떤 지원이나 객체의 잠금 획득 할 수 있음
- 사용자명으로 사용자를 유일하게 식별할 수 있어야 하므로 오직 한며으이 사용자만 특정한 사용자명으로 등록할 수 잇음

## (#) 펜싱 토큰
자신이 '선택된 자'라고 잘못 믿고 있는 노드가 나머지 시스템을 방해할 수 없도록 보장 (펜싱)

## (4) ㅂ;진ㅌ;ㄴ 걀힘
비잔팀 결함 : 어떤 노드가 실제로 받지않는 특정메세지를 받았다고 주장 


## (5) 약한 형태의 거짓말

## (6) 시스템 모델과 현실

- 동기식 모델 : 네트워크 지연, 프로세스 중단 시계 요차에 모두 제한이 있다고 가정, 어떤 고정된 상한치를 초과하지 않을 것임을 안다

- 부분동기식 모델 : 시스템이 대부분의 시간에는 동기식 시스템처럼 동작하지ㅏㄴ 떄떄로 네트워크 지연, 프로세스 중단, 시계 드리프트의 한계치를 초과한다

- 비동기식 모델 : 타이밍에 대한 어떤 가정도 할 수없음

- 죽으면 중단한느 결함(crash-stop)

- 죽으면 복구하는 결함(crash-recovery)

- 비잔틴 결함

## (7) 알고리즘의 정확성
## (8) 안정성과 활동성
활동성 속성 '결국에는'이라는단어 포함, 최종적 일관성

- 안정성 속성이 위반되면 그 속성이 깨진 특정 시점을 가리킬 수 있음, 안정성 속성이 위반된 후에는 위반 취소할 수업음
- 활동성 속성은 반대로 동작, 어떤 시점을 정하지못할 수 있지만 항상 미래에 그 속성을 만족시킬 수 있다는 희망이 있음

## (9) 시스템 모델을 현실 세계에 대응시키기
