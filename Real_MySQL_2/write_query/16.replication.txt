16.replication

16.1 개요

(1) 스케일 아웃
(2) 데이터 백업
(3) 데이터 분석
(4) 데이터의 지리적 분산

16.2 복제 아키텍처

- 바이너리 로그 : 서버에서 발생하는 모든 변경 사항 별도의 로그 파일에 순서대로 기록
- 이벤트 : 바이너리 로그에 기록된 각 변경 정보
- 릴레이 로그 : 레플리카 서버에서 소스 서버의 바이너리 로그를 읽어 들여 로컬 디스크에 저장해둔 파일


# 스레드의 역할
- 바이너리 로그 덤프 스레드 : 레플리카 서버는 데이터 동기화를 위해 소스 서버에 접속해 바이너리 로그 정보를 요청
바이너리 로그 내용을 레플리카 서버로 전송

- 레플리케이션 I/O 스레드 : 복제가 시작되면 레플리카 서버는 I/O 스레드를 생성, 복제가 멈추면 I/O 스레드는 종료됨
I/O 스레드는 소스 서버의 바이너리 로그 덤프 스레드로부터 바이너리 로그 이벤트를 가져와 로컬 서버의 파일로 저장하는 역할

- 레플리케이션 SQL 스레드 : 레플리케이션 I/O 스레드가 소스 서버로부터 가져온 바이너리 로그 이벤트들을 로컬 파일로 기록하는 역할이라면,
레플리케이션 SQL 스레드는 I/O 스레드에 의해 작성된 릴레이 로그 파일의 이벤트들을 읽고 실행

16.3 복제 타입
바이너리 로그 이벤트들을 식별한느 방식에 따라 '바이너리 로그 파일 위치 기반 복제', '글로벌 트랜잭션 ID기반 복제'

16.3.1 바이너리 로그 파일 위치 기반 복제

레플리카 서버에서 소스 서버의 바이너리 로그 파일명과 파일 내에서의 위치로 개별 바이너리 로그 이벤트를 식별 복제가 진행되는 형태를 말함

MySQL 서버가 고유한 server_id 값을 갖도록 설정

16.3.1.1 바이너리 로그 파일 위치 기반의 복제 구축

16.3.1.1.1 설정 준비
'SHOW MASTR STATUS' 명령 실행

16.3.1.1.2 복제 계정 준비
레플리카 서버가 소스 서버로부터 바이너리 로그를 가져오려면 소스 서버에 접속해야하므로 접속 시 사용할 DB계정이 필요함, '복제용 계정'

16.3.1.1.3 데이터복사
mysql 엔터프라이즈 백업이나 mysqldump등과 같은 툴을 사용해 , 소스 서버에서 데이터를 내려받아 레플리카 서버로 복사

'--single-transaction' : 데이터를 덤프할 때 하나의 트랜잭션을 사용해 InnoDB 테이블에 대해 일관된 데이터를 덤프받을 수 있게함
'--master-data' : 덤프 시작 시점의 소스 서버의 바이너리 로그 파일명과 위치, 복제 연결을 위해 반드시 필요한 옵션


16.3.1.1.4 복제 시작

16.3.1.2 바이너리 로그 파일 위치 기반의 복제에서 트랜잭션 건너뛰기
'sql-slave-skip-count' 시스템 변수를 이용해 문제되는 트랜잭션 건너띌수있음

16.3.2 글로벌 트랜잭션 아이디 기반 복제
동일한 이벤트가 레플리카 서버에서도 동일한 파일명의 동일한 위치에 저장된다는 보장이 없음, 복제에 투입된 서버들마다 동일한 이벤트에 대해 서로 다른 식별 값을 갖게됨


소스 서버에서 발생한 각 이벤트들이 복제에 참여한 모든 MySQL 서버들에서 동일한 고유 식별값을 가진다면
GTID(Global transaction Identifier)

16.3.2.1 GTID의 필요성

16.3.2.2 글로벌 트랜잭션 아이디

'gtid_executed' 시스템 변수를 통해 확인할 수 있음

16.3.2.3 글로벌 트랜잭션 아이디 기반의 복제 구축

16.3.2.3.1 설정 준비
16.3.2.3.2 복제 계정 준비
16.3.2.3.3 데이터 복사
16.3.2.3.4 복제 시작


16.3.2.4 글로벌 트랜잭션 아이디 기반 복제에서 트랜잭션 건너뛰기

16.3.2.5 Non-GTID 기반 복제에서 GTID 기반 복제로 온라인 변경

16.4 복제 데이터 포맷

- STATEMENT V포맷 : 실행된 sql문을 바이너리 로그에 기록
    - DELETE/UPDATE 쿼리에서 ORDER BY 절 없이 LIMIT을 사용
    - SELECT ... FOR UPDATE 및 SELECT ... FOR SHARE 쿼리에서 NOWAT이나 SKIP LOCKED 옵션 사용
    - LOAD_FILE(), UUID(), UUID_SHORT(), USER(), RAND() 등과 같은 함수를 사용한느 쿼리를
    - 동일한 파라미터 값을 입력하더라도 결괏값이 달라질 수 있는 사용자 정의 함수나 스토어드 프로시저를 사용하는 쿼리를

ROW포맷으로 복제될 때보다 데이터레 락을 더 많이 검

16.4.2 Row 기반 바이너리 로그 포맷
어떤 형태의 쿼리가 실행됐든 간에 복제 시 소스 서버와 레플리카 서버의 데이터를 일관되게 하는 가장 안전한 방식
어떤 변경 이벤트건 더 작은 락을 점유하여 처리

16.4.3 Mixed 포맷

16.4.4 Row 포맷의 용량 최적화

16.4.4.1 바이너리 로그 Row 이미지

binlog_row_image 시스템 변수 제공

- full : 특정 칼럼에서만 변경 여부와 관계없이 변겨잉 발생한 레코드의 모든 칼럼들의 값을 바이너리 로그에 기록하는 방식

- minimal : 변경 데이터에 대해 꼭 필요한 칼럼들의 값만 바이너리 로그에 기록
- noblob : full 옵션을 설정한 것과 동일하게 작동, 레코드의 BLOB이나 TEXT 칼럼에 대해 변경이 발생하지않은 경우 해당칼럼들은 바이너리 로그 파일에 기록하지않음


16.4.4.2 바이너리 로그 트랜잭션 압축

16.5 복제 동기화 방식
<<<<<<< HEAD
변경 이벤트가 정상적으로 전달됐는지 확인하지 않는 방식

소스서버가 레플리카 서버의 동기화 여부를 보장하지 않음

16.5.2 반동기 복제

소스 서버는 레플리카 서버가 소스 서버로부터 전달받은 변경 이벤트를 릴레이 로그에 기록 후 응답을 보내면 트랜잭션을 완전히 커밋시키고 클라이언트게 결과를 반환

16.5.2.1 반동기 복제 설정 방법
플러그인 설치, information_schema.PLUGINS

16.6 복제 토폴리지

16.6.1 싱글 레플리카 복제 구성

소스 서버에 하나의 레플리카 서버만 연결돼 있는 복제 형태

16.6.2 멀티 레플리카 복제 구성

16.6.3 체인 복재 구성
OLTP 서비스 용도, 통계나 배치, 백업 용도로 구분해서 사용


16.6.4 듀얼 소스 복제 구성
두 개의 MySQL 서버가 서로 소스 서벙자 레플리카 서버로 구성돼 있는 형태를 말하

16.6.5 멀티 소스 복제 구성
하나의 레플리카 서버가 둘 이상의 소스 서버를 갖는 형태를 말함

16.6.5.1 멀티 소스 복제 동작

16.6.5.2 멀티 소스 복제 구축

16.7 복제 고급 설정

16.7.1 지연된 복제

16.7.2 멀티 스레드 복제 (Multi-threaded Replication)
레플리카 서버에서 소스서버로부터 복제된 트랜잭션들을 하나의 스레드가 아닌 여러 스레드로 처리할 수 있게 하는 멀티 스레드 복제 기능을 제공

'코디네이터 스레드', 워커 스레드와 협업해서 동기화를 진행

16.7.2.1 데이터베이스 기반 멀티 스레드 복제
스키마 기반 처리방식, 
서로 다르 ㄴ데이터베이스를 참조하는 쿼리나 트랜잭션이 빈번하게 실행ㅇ되는 경우 예사앻ㅆ떤 것보다 멀티 스레드 처리 효율이 낮아질수 있음

16.7.2.2 Logical clock 기반 멀티 스레드 복제
소스 서버에서 트랜잭션들이 바이너리 로그로 기록될 때 각 트랜잭션별로 논리적인 순번 값을 부여해 레플리카 서버에서 트랜잭션의 순번 값을 바탕으로 정해진 기준에 따라
병렬로 실행할 수 있게 하는 방식

16.7.2.2.1 바이너리 로그 그룹 커밋

분산 트랜잭션 : 트랜잭션을 커밋할 떄 스토리지 엔진에 적용된 내용과 바이너리 로그에 기록된 내용 간의 일관성을 유지하기 위해 사용

1.Flush 단계 : 대기 큐에 등록된 각 트랜잭션들을 순서대로 바이너리 로그에 기록
2.Sync 단계 : 앞서 기록된 바이너리 로그 내용들을 디스크와 동기화하는 fsync() 시스템 콜이 수행
3.Commit 단계 : 대기 큐에 등록된 트랜잭션들에 대해 스토리지 엔진 커밋을 진행

16.7.2.2.2 Commit-parent 기반 Logical clock 방식

Logical clock 멀티 스레드 동기화가 활성화돼 있는 경우 소스 서버에서 같은 시점에 커밋된 트랜잭션들을 복제 동기화할 병렬로 처리

16.7.2.2.3 잠금 기반 Logical Clock 방식

16.7.2.2.4 WriteSet 기반 Logical Clock 방식
트랜잭션의 커밋 처리 시점이 아닌 트랜잭션이 변경한 데이터를 기준으로 병렬 처리 가능 여부를 결정

16.7.2.3 멀티 스레드 복제와 복제 포지션 정보

16.7.3 크래시 세이프 복제 (crash-safe replication)

16.7.3.1 서버 장애와 복제 실패

- I/O 스레드가 릴레이 로그에 이벤트를 기록한 후 아직 포지션 정보 파일에 업데이트를 하지않은 상태에서 MySQL이 비정상 종료되면 
MySQL을 재구동할 때 릴레이 로그에 동일한 이벤트가 기록될 수 있음

- SQL 스레드가 릴레이 로그에 리고된 트랜잭션을 커밋한 후 아직 포지션 정보 파일에 업데이트를 하지않은 상태에서 MySQL이 비정상 종료되면 MySQL을 재구동할 때동일한 트랜잭션이 재실행디ㅗㄹ 수 있따

relay_log_recovery옵션이 도입되면서 해결, 

16.7.3.2 복제 사용 형태별 크래시 세이프 복제 설정


16.7.3.2.1 바이너리 로그 파일 위치 기반 복제 + 싱글 스레드 동기화


16.7.3.2.2 바이너리 로그 파일 위치 기반 복제 + 멀티 스레드 동기화

16.7.3.2.3 GTID 기반 복제 + 싱글 스레드 동기화

16.7.3.2.4 GTID 기반 복제 + 멀티 스레드 동기화

16.7.4 필터링된 복제

- binnlog-do-do : 바이너리 로그에 기록할 데이터베이스 명을 지정
- binlog-ignore-db : 바이너리 로그에 기록하지 않을 데이터베이스명을 지정

=======

16.5.1 비동기 복제
>>>>>>> 5ef881c617a2e608029d1a02ee6b08cbc70fa6a0
