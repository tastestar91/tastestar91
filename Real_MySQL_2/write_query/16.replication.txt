16.replication

16.1 개요

(1) 스케일 아웃
(2) 데이터 백업
(3) 데이터 분석
(4) 데이터의 지리적 분산

16.2 복제 아키텍처

- 바이너리 로그 : 서버에서 발생하는 모든 변경 사항 별도의 로그 파일에 순서대로 기록
- 이벤트 : 바이너리 로그에 기록된 각 변경 정보
- 릴레이 로그 : 레플리카 서버에서 소스 서버의 바이너리 로그를 읽어 들여 로컬 디스크에 저장해둔 파일


# 스레드의 역할
- 바이너리 로그 덤프 스레드 : 레플리카 서버는 데이터 동기화를 위해 소스 서버에 접속해 바이너리 로그 정보를 요청
바이너리 로그 내용을 레플리카 서버로 전송

- 레플리케이션 I/O 스레드 : 복제가 시작되면 레플리카 서버는 I/O 스레드를 생성, 복제가 멈추면 I/O 스레드는 종료됨
I/O 스레드는 소스 서버의 바이너리 로그 덤프 스레드로부터 바이너리 로그 이벤트를 가져와 로컬 서버의 파일로 저장하는 역할

- 레플리케이션 SQL 스레드 : 레플리케이션 I/O 스레드가 소스 서버로부터 가져온 바이너리 로그 이벤트들을 로컬 파일로 기록하는 역할이라면,
레플리케이션 SQL 스레드는 I/O 스레드에 의해 작성된 릴레이 로그 파일의 이벤트들을 읽고 실행

16.3 복제 타입
바이너리 로그 이벤트들을 식별한느 방식에 따라 '바이너리 로그 파일 위치 기반 복제', '글로벌 트랜잭션 ID기반 복제'

16.3.1 바이너리 로그 파일 위치 기반 복제

레플리카 서버에서 소스 서버의 바이너리 로그 파일명과 파일 내에서의 위치로 개별 바이너리 로그 이벤트를 식별 복제가 진행되는 형태를 말함

MySQL 서버가 고유한 server_id 값을 갖도록 설정

16.3.1.1 바이너리 로그 파일 위치 기반의 복제 구축

16.3.1.1.1 설정 준비
'SHOW MASTR STATUS' 명령 실행

16.3.1.1.2 복제 계정 준비
레플리카 서버가 소스 서버로부터 바이너리 로그를 가져오려면 소스 서버에 접속해야하므로 접속 시 사용할 DB계정이 필요함, '복제용 계정'

16.3.1.1.3 데이터복사
mysql 엔터프라이즈 백업이나 mysqldump등과 같은 툴을 사용해 , 소스 서버에서 데이터를 내려받아 레플리카 서버로 복사

'--single-transaction' : 데이터를 덤프할 때 하나의 트랜잭션을 사용해 InnoDB 테이블에 대해 일관된 데이터를 덤프받을 수 있게함
'--master-data' : 덤프 시작 시점의 소스 서버의 바이너리 로그 파일명과 위치, 복제 연결을 위해 반드시 필요한 옵션


16.3.1.1.4 복제 시작

16.3.1.2 바이너리 로그 파일 위치 기반의 복제에서 트랜잭션 건너뛰기
'sql-slave-skip-count' 시스템 변수를 이용해 문제되는 트랜잭션 건너띌수있음

16.3.2 글로벌 트랜잭션 아이디 기반 복제
동일한 이벤트가 레플리카 서버에서도 동일한 파일명의 동일한 위치에 저장된다는 보장이 없음, 복제에 투입된 서버들마다 동일한 이벤트에 대해 서로 다른 식별 값을 갖게됨


소스 서버에서 발생한 각 이벤트들이 복제에 참여한 모든 MySQL 서버들에서 동일한 고유 식별값을 가진다면
GTID(Global transaction Identifier)

16.3.2.1 GTID의 필요성

16.3.2.2 글로벌 트랜잭션 아이디

'gtid_executed' 시스템 변수를 통해 확인할 수 있음

16.3.2.3 글로벌 트랜잭션 아이디 기반의 복제 구축

16.3.2.3.1 설정 준비
16.3.2.3.2 복제 계정 준비
16.3.2.3.3 데이터 복사
16.3.2.3.4 복제 시작


16.3.2.4 글로벌 트랜잭션 아이디 기반 복제에서 트랜잭션 건너뛰기

16.3.2.5 Non-GTID 기반 복제에서 GTID 기반 복제로 온라인 변경

16.4 복제 데이터 포맷

- STATEMENT V포맷 : 실행된 sql문을 바이너리 로그에 기록
    - DELETE/UPDATE 쿼리에서 ORDER BY 절 없이 LIMIT을 사용
    - SELECT ... FOR UPDATE 및 SELECT ... FOR SHARE 쿼리에서 NOWAT이나 SKIP LOCKED 옵션 사용
    - LOAD_FILE(), UUID(), UUID_SHORT(), USER(), RAND() 등과 같은 함수를 사용한느 쿼리를
    - 동일한 파라미터 값을 입력하더라도 결괏값이 달라질 수 있는 사용자 정의 함수나 스토어드 프로시저를 사용하는 쿼리를

ROW포맷으로 복제될 때보다 데이터레 락을 더 많이 검

16.4.2 Row 기반 바이너리 로그 포맷
어떤 형태의 쿼리가 실행됐든 간에 복제 시 소스 서버와 레플리카 서버의 데이터를 일관되게 하는 가장 안전한 방식
어떤 변경 이벤트건 더 작은 락을 점유하여 처리

16.4.3 Mixed 포맷

16.4.4 Row 포맷의 용량 최적화

16.4.4.1 바이너리 로그 Row 이미지

binlog_row_image 시스템 변수 제공

- full : 특정 칼럼에서만 변경 여부와 관계없이 변겨잉 발생한 레코드의 모든 칼럼들의 값을 바이너리 로그에 기록하는 방식

- minimal : 변경 데이터에 대해 꼭 필요한 칼럼들의 값만 바이너리 로그에 기록
- noblob : full 옵션을 설정한 것과 동일하게 작동, 레코드의 BLOB이나 TEXT 칼럼에 대해 변경이 발생하지않은 경우 해당칼럼들은 바이너리 로그 파일에 기록하지않음


16.4.4.2 바이너리 로그 트랜잭션 압축