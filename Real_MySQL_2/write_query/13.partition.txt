13. PARTITION

13.1 개요

13.1.1 파티션을 사용하는 이유
하나의 테이블이 너무 커서 인덱스의 크기가 물리적인 메모리보다 훨씬 크거나 데이터 특성상 주기적인 삭제 작업이 필요한 경우

13.1.1.1 단일 INSERT와 단일 또는 범위 SELECT의 빠른 처리

파티션은 데이터와 인덱스를 조각화해서 물리적 메모리를 효율적으로 사용할 수 있게끔 만듬

13.1.1.2 데이터의 물리적인 저장소를 분리

위킹 셋: 활발하게 사용되는 데이터

13.1.1.3 이력 데이터의 효율적인 관리

13.1.2 MySQL 파티션의 내부처리

13.1.2.1 파티션 테이블의 레코드 INSERT

13.1.2.2 파티션 테이블의 UPDATE

13.1.2.3 파티션 테이블의 검색

- where 절의 조건으로 검색해야할 파티션을 선택할 수 있는가?
- where 절의 조건이 인덱스를 효율적으로 사용할 수 있는가? (인덱스 레인지 스캔)

- 파티션 선택 가능 + 인덱스 효율적 사요가능 : 꼭 필요한 파티션의 인덱스만 레인지 스캔
- 파티션 선택 불가 + 인덱스 효율적 사용 가능 : 테이블의 모든 파티션을 대상으로 검색, 테이블에 존재하는 모든 파티션의 개수만큼 인덱스 레인지 스캔을 수행
- 파티션 선택 가능 + 인덱스 효율적 사용 불가 : 파티션 개수와 관계없이 검색을 ㅜ이해 필요한 파티션만 읽으면 됨, 대상 파티션에 대해 풀 테이블 스캔
- 파티션 선택 불가 + 인덱스 효율적 사용 불가 : 테이블의 모든 파티션을 검색, 풀 테이블 스캔 수행

13.1.2.4 파티션 테이블의 인덱스 스캔과 정렬

여러 파티션에 대해 인덱스 스캔을 수행할 떄 각 파티션으로부터 조건에 일치하는 레코드를 정렬된 순서대로 읽으면서 우선순위 큐에 임시로 저장
mysql 서버가 별도의 정렬 작업을 수행하지않음

13.1.2.5 파티션 프루닝
 필요한 파티션만 골라내고 불필요한 것들을 실행 계획에서 배제하는 것을 파티션 프루닝이라고 함


 13.2 주의사항

13.2.1  파티션의 제약 사항

- 스토어드 루틴이나 UDF, 사용자 변수등을 파티션 표현식에 사용할 수 없음
- 파티션 표현식은 일반적으로 칼럼 그 자체 또는 MySQL 내장 함수를 사용할 수 있는데, 파티션 생성은 가능 파티션 프루닝을 지원하지 않을 수 있음
- 프라이머리 키를 포함해서 테이블의 모든 유니크 인덱스는 파티션 키 칼럼을 포함해야함
- 파티션된 테이블의 인덱스는 모두 로컬 인덱스, 동일 테이블에 소속된 모든 파티션은 같은 구조의 인덱스만 가질 수 있음
- 동일 테이블에 속한 모든 파티션은 동일 스토리지 엔진만 가질 수 있음
- 최대 8192개의 파티션을 가질 수 있음
- 파티션 생서어 이후 MySQL 서버의 sql_mode 시스템 변수 변경은 데이터 파티션의 일관성을 꺠뜨릴 수 있음
- 파티션 테이블에서는 외래키 사용할 수 없음
- 파티션 테이블 전문 검색 인덱스 생성이나 전문 검색 쿼리를 사용할 수 없음
- 공간 데이터를 저장하는 칼럼 타입은 파티션 테이블에서 사용할 수 없음
- 임시 테이블은 파티션 기능 사용할 수 없음

파티션 키로 사용되는 칼럼은 반드시 프라이머리 키 일불 참여해야함 (제약 사항)

13.2.2 파티션 사용 시 주의사항

유니크 인덱스는 중복 레코드에 대한 체크 작업 때문에 범위가 좁혀지지 않음

13.2.2.1 파티션과 유니크 키(프라이머리 키 포함)

13.2.2.2 파티션과 open_files_limit 시스템 변수 설정
테이블을 파일 단위로 관리, 

13.3 MySQL 파티션의 종류 

- 레인지 파티션
- 리스트 파티션
- 해시 파티션
- 키 파티션

13.3.1 레인지 파티션

13.3.1.1 레인지 파티션의 용도

- 날짜를 기반으로 데이터가 누적되고 연도나 월, 또는 일 단위로 분석하고 삭제해야 할 때
- 범위 기반으로 데이터를 여러 파티션에 균등하게 나눌 수 있을 때
- 파티션 키 위주로 검색이 자주 실행될 때

13.3.1.2 레인지 파티션 테이ㅡㄹ 생성

PARTITION BY RANGE( YEAR(hired) ) (
    PARTITION p0 VALUES LESS THAN (1991),
    PARTITION p1 VALUES LESS THAN (1996),
    PARTITION p2 VALUES LESS THAN (2001),
)
- PARTITION BY RANGE : 레인지 파티션을 정의
- PARTITION BY RAGE 뒤에 칼럼 또는 내장 함수를 이용해 파티션 키를 명시
- VALUES LESS TAN으로 명시된 값보다 작은 값만 해당 파티션에 저장하게 설정


13.3.1.3 레인지 파티션의 분리와 병합

13.3.1.3.1 단순 파티션의 추가할
ALTER TABLE ... REORGANIZE PARTITION

13.3.1.3.2 파티션 삭제
DROP PARTITOIN 삭제하려는 파티션의 이름을 지정된
가장 오래된 파티션만 삭제할 수 있음

13.3.1.3.3 기존 파티션의 분리
ALTER TABLE employees ALGORITHM=INPLACE, LOCK=SHARED, REORGANIZE PARTITION p3 INFO 

13.3.1.3.4 기존 파티션의 병합

파티션을 병합하는 경우에도 파티션 재구성이 필요, 테이블에 대해서 읽기 잠금 필요

13.3.2 리스트 파티션
레인지 파티션은 파티션 키 값의 범위로 파티션을 구성할 수 있지만 리스트 파티션은 파티션 키 값 하나하나를 리스트로 나열해야함

13.3.2.1 리스트 파티션의 용도
- 파티션 키 값이 코드 값이나 카테고리와 같이 고정적일 떄
- 키 값이 연속되지 않고 정렬 순서와 관계없이 파티션을 해야할 때
- 파티션 키 값을 기준으로 레코드의 건수가 균일하고 검색 조건에 파티션 키가 자주 사용될 떄

13.3.2.2 리스트 파티션 테이블 생성

13.3.2.3 리스트 파티션의 분리와 병합
VALUES LESS THAN 이 아닌 VALUES IN을 사용한다는 것 외에 레인지 파티션의 추가 및 삭제, 병합 작업 모두 같음

13.3.2.4 리스트 파티션 주의사항
- 명시되지 않은 나머지 값을 저장하는 MAXVALUE 파티션을 정의할 수 없음
- 레인지 파티션과는 달리 NULL을 저장하는 파티션을 별도로 생성할 수 있음

13.3.3 해시 파티션
MySQL에서 정의한 해시 함수에 의해 레코드가 저장될 파티션을 결정하는 방법
파티션 표현식의 결괏값을 파티션의 개수로 나눈 나머지로 저장될 파티션ㅇ늘 결정하는 방식, 파티션 키는 항상 정수 타입의 칼럼이거나 정수를 반환하는 표현식만 사용될 수 있음

13.3.3.1 해시 파ㅣ션의 용도
- 레인지 파티션이나 리스트 파티션으로 데이터를 균등하게 나누는게 어려울 때
- 테이블의 모든 레코드가 비슷한 사용 빈도를 보이지만 테이블이 너무 커서 파티션을 적용해야할 때

13.3.3.2 해시 파티션 테이블 생성
- PARTITION BY HASH(id) : 파티션 종류를 해시 파티션으로 지정
- PARTITION BY HASH 키워드 뒤에 파티션 키를 명시
해시 파티션의 파티션 키 또는 파티션 표현식은 반드시 정수 타입의 값을 반환
PARTITIONS n으로 몇 개의 파티션을 생성할 것인지 명시
파티션의 개수뿐만 아니라 각 파티션의 이름을 명시하려면 위 예제의 두 번쨰 CREATE TABLE 명령과 같이 각 파티션을 나열하면 됨

13.3.3.3 해시 파티션의 분리와 병합

13.3.3.3.1 해시 파티션 추가
특정 파티션 키 값을 테이블의 파티션 개수로 MOD 연산한 결괏값에 의해 각 레코드가 저장될 파티션을 결정, 
파티션 개수에 의해 알고리즘이 변함

13.3.3.3.2 해시 파티션 삭제
파티션 단위로 레코드를 삭제하는 방법이 없음

MySQL 서버가 지정한 파티션 키 값을 가공해서 데이터를 가 ㄱ파티션으로 분산한 것이므로 각 파티션에 저장된 레코드가 어떤 부류의 데이터인지 사용자가 예측할 수 없음

13.3.3.3.3 해시 파티션 분할
테이블 전체적으로 파티션 개수를 늘리는 것만 가능

13.3.3.3.4 해시 파티션 병합
파티션의 개수를 줄일 때는 COALESCE PARTITION 명령을 사용하면 됨

13.3.3.3.5 해시 파티션 주의 사항
- 특정 팥션만 삭제하는 것은 불가능
- 새로운 파티션을 추가하는 작업은 단순히 파티션만 추ㅏ하는게 아니라 기존 모든 데이터의 재배치 작업이 필요함
- 해시 파티션은 레인지 파티션이나 리스트 파티션과는 다른 방식으로 관리, 해시 파티션이 용도에 적합한 해결책인지 확인 필요
- 사용자들에게 익숙한 파티션의 조직이나 특성은 대부분 리스트 파티션이나 레인지 파티션에만 해당하는 것들이 많음

13.3.4 키 파티션
해시 파티션은 해시 값을 계산하는 방법을 파티션 키나 표현식에 사용자가 명시, 키 파티션은 해시 값의 계산도 MySQL 서버가 수행함

- PARTITION BY KEY 키워드로 파티션을 정의
- MYSQL 서버가 자동으로 프라이머리 키나 유니크 키의 모든 칼럼을 파티션 키로 선택
- 프라이머리 키나 유니크 키를 규성하는 칼럼 중에 일부만 파티션 키로 명시하는 것도 가능
- PARTITIONS 키워드로 생성할 파티션 개수를 지정

13.3.4.2 키 파티션 주의사항 및 특이사항
- 키 파티션은 내부적으로 MDS()함수를 이요해 파티션하기 떄무넹 파티션 키가 반드시 정수타입이 아니어도됨
- 프라이머리 키나 유니크 키를 구성하는 칼럼 중 일부만으로 파티션할 수 있음
- 유니크 키를 파티션 키로 사용할 떄 해당 유니크 키는 반드시 NOT NULL 이어야 함
- 해시 파티션에 비해 파티션 간의 레코드를 더 균등하게 분할할 수 있기 떄문에 키 파티션이 더 효율적

13.3.5 리니어 해시 파티션/ 리니어 키 파티션
전체 파티션에 저장된 레코드의 재분배 작업이 발생, 이러한 단점 최소화하기 위해 리니어 해시 파티션/ 리니어 키 파티션 알고리즘이 고안
'Power-of-two'알고리즘을 이요

13.3.5.1 리니어 해시 파티션/ 리니어 키 파티션의 추가 및 통합
파티션의 추가나 통합 시 특정 파티션의 데이터에 대해서만 ㅣ동 작업을 하면 됨

13.3.5.1.1 리니어 해시 파티션/ 리니어 키 파티션의 추가

13.3.5.1.2 리니어 해시 파티션 / 리니어 키 파티션의 통합

13.3.5.1.3 리니어 해시 파티션 / 리니어 키 파티션 관련된 주의사항

13.3.6 파티션 테이블의 쿼리 성능
얼마나 많은 파티션을 프루닝할 수 있는지가 관건


